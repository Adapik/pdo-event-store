[{"id":"\/intro.html#1","title":"Introduction","content":"The PDO Event Store is an implementation of prooph\/event-store that supports MySQL and MariaDB as well as PostgreSQL."},{"id":"\/intro.html#1-1","title":"Video Introduction","content":""},{"id":"\/intro.html#1-2","title":"Installation","content":"composer require prooph\/pdo-event-store "},{"id":"\/intro.html#1-3","title":"Requirements","content":" PHP &gt;= 7.1 PDO_MySQL Extension or PDO_PGSQL Extension For MariaDB you need server vesion &gt;= 10.2.6. For MySQL you need server version &gt;= 5.7.9. For Postgres you need server version &gt;= 9.4."},{"id":"\/intro.html#1-4","title":"Setup","content":"For MariaDB run the script in scripts\/mariadb\/01_event_streams_table.sql on your server.For MySQL run the script in scripts\/mysql\/01_event_streams_table.sql on your server.For Postgres run the script in scripts\/postgres\/01_event_streams_table.sql on your server.This will setup the required event streams table.If you want to use the projections, run additionally the scripts scripts\/mariadb\/02_projections_table.sql (for MariaDB), scripts\/mysql\/02_projections_table.sql (for MySQL) or scripts\/postgres\/02_projections_table.sql (for Postgres) on your server."},{"id":"\/variants.html#2","title":"Variants","content":"The PDO Event Store is an implementation of prooph\/event-store that supports MySQL and MariaDB as well as PostgreSQL.For a better understanding, we recommend to read the event-store docs, first."},{"id":"\/variants.html#2-1","title":"Differences of MariaDb-\/MySql- &amp; PostgresEventStore","content":"The PostgresEventStore has a better performance (at least with default database configuration) and implements the TransactionalEventStore interface. If you need maximum performance or transaction support, we recommend to use the PostgresEventStore over the MariaDb-\/MySqlEventStore."},{"id":"\/variants.html#2-2","title":"Event streams \/ projections table","content":"All known event streams are stored in an event stream table, so with a simple table lookup, you can find out what streams are available in your store.Same goes for the projections, all known projections are stored in a single table, so you can see what projections are available, and what their current state \/ stream positition \/ status is."},{"id":"\/variants.html#2-3","title":"Load batch size","content":"When reading from an event streams with multiple aggregates (especially when using projections), you could end of with millions of events loaded in memory. Therefor the pdo-event-store will load events only in batches of 1000 by default. You can change to value to something higher to achieve even more performance with higher memory usage, or decrease it to reduce memory usage even more, with the drawback of having a not as good performance."},{"id":"\/variants.html#2-4","title":"PDO Connection for event-store and projection manager","content":"It is important to use the same database for event-store and projection manager, you could use distinct pdo connections if you want to, but they should be both connected to the same database. Otherwise you will run into issues, because the projection manager needs to query the underlying database table of the event-store for its querying API.It's recommended to just use the same pdo connection instance for both."},{"id":"\/variants.html#2-5","title":"Persistance Strategies","content":"This component ships with 9 default persistance strategies: MariaDbAggregateStreamStrategy MariaDbSimpleStreamStrategy MariaDbSingleStreamStrategy MySqlAggregateStreamStrategy MySqlSimpleStreamStrategy MySqlSingleStreamStrategy PostgresAggregateStreamStrategy PostgresSimpleStreamStrategy PostgresSingleStreamStrategy All persistance strategies have the following in common:The generated table name for a given stream is:'_' . sha1($streamName-&gt;toString()so a sha1 hash of the stream name, prefixed with an underscore is the used table name. You can query the event_streams table to get real stream name to stream name mapping.You can implement your own persistance strategy by implementing the Prooph\\EventStore\\Pdo\\PersistenceStrategy interface."},{"id":"\/variants.html#2-5-1","title":"AggregateStreamStrategy","content":"This stream strategy should be used together with event-sourcing, if you use one stream per aggregate. For example, you have 2 instances of two different aggregates named user-123, user-234, todo-345 and todo-456, you would have 4 different event streams, one for each aggregate.This stream strategy is the most performant of all, but it will create a lot of database tables, which is something not everyone likes (especially DB admins).All needed database tables will be created automatically for you."},{"id":"\/variants.html#2-5-2","title":"SingleStreamStrategy","content":"This stream strategy should be used together with event-sourcing, if you want to store all events of an aggregate type into a single stream, for example user-123 and user-234 should both be stored into a stream called user.You can also store all stream of all aggregate types into a single stream, for example your aggregates user-123, user-234, todo-345 and todo-456 can all be stored into a stream called event_stream.This stream strategy is slightly less performant then the aggregate stream strategy.You need to setup the database table yourself when using this strategy. An example script to do that can be found here."},{"id":"\/variants.html#2-5-3","title":"SimpleStreamStrategy","content":"This stream strategy is not meant to be used for event-sourcing. It will create simple event streams without any constraints at all, so having two events of the same aggregate with the same version will not rise any error.This is very useful for projections, where you copy events from one stream to another (the resulting stream may need to use the simple stream strategy) or when you want to use the event-store outside the scope of event-sourcing.You need to setup the database table yourself when using this strategy. An example script to do that can be found here."},{"id":"\/variants.html#2-5-4","title":"Using custom stream strategies","content":"When you query the event streams a lot, it might be a good idea to create your own stream strategy, so you can add custom indexes to your database tables. When using with the MetadataMatcher, take care that you add the metadata matches in the right order, so they can match your indexes."},{"id":"\/variants.html#2-5-5","title":"Disable transaction handling","content":"You can configure the event store to disable transaction handling completely. In order to do this, set the last parameter in the constructor to true (or configure your interop config factory accordingly, key is disable_transaction_handling).Enabling this feature will disable all transaction handling and you have to take care yourself to start, commit and rollback transactions.Note: This could lead to problems using the event store, if you did not manage to handle the transaction handling accordingly. This is your problem and we will not provide any support for problems you encounter while doing so."},{"id":"\/interop_factories.html#3","title":"Interop Factories","content":"Instead of providing a module, a bundle, a bridge or similar framework integration prooph\/event-store ships with interop factories."},{"id":"\/interop_factories.html#3-1","title":"Factory-Driven Creation","content":"The concept behind these factories (see src\/Container folder) is simple but powerful. It allows us to provide you with bootstrapping logic for the event store and related components without the need to rely on a specific framework. However, the factories have three requirements."},{"id":"\/interop_factories.html#3-1-1","title":"Requirements","content":" Your Inversion of Control container must implement the PSR Container interface. interop-config must be installed The application configuration should be registered with the service id config in the container. Note: Don't worry, if your environment doesn't provide these requirements, you can always bootstrap the components by hand. Just look at the factories for inspiration in this case."},{"id":"\/interop_factories.html#3-1-2","title":"MariaDbEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; MariaDbSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MariaDbEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\MariaDbEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('MariaDbEventStore');"},{"id":"\/interop_factories.html#3-1-3","title":"MariaDbProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'MariaDbEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MariaDbProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\MariaDbProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('MariaDbProjectionManager');"},{"id":"\/interop_factories.html#3-1-4","title":"MySqlEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; MySqlSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MySqlEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\MySqlEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('MySqlEventStore');"},{"id":"\/interop_factories.html#3-1-5","title":"MySqlProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'MySqlEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'MySqlProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\MySqlProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('MySqlProjectionManager');"},{"id":"\/interop_factories.html#3-1-6","title":"PostgresEventStoreFactory","content":"If the requirements are met you just need to add a new section in your application config ...[ 'prooph' =&gt; [ 'event_store' =&gt; [ 'default' =&gt; [ 'wrap_action_event_emitter' =&gt; true, 'metadata_enrichers' =&gt; [ \/\/ The factory will get the metadata enrichers and inject them in the MetadataEnricherPlugin. \/\/ Note: you can obtain the same result by instanciating the plugin yourself \/\/ and pass it to the 'plugin' section bellow. 'metadata_enricher_1', 'metadata_enricher_2', \/\/ ... ], 'plugins' =&gt; [ \/\/And again the factory will use each service id to get the plugin from the container \/\/Plugin::attachToEventStore($eventStore) is then invoked by the factory so your plugins \/\/ get attached automatically \/\/Awesome, isn't it? 'plugin_1_service_id', 'plugin_2_service_id', \/\/... ], 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'persistence_strategy' =&gt; PostgresSingleStreamStrategy::class, \/\/ service id for the used persistance strategy 'load_batch_size' =&gt; 1000, \/\/ how many events a query should return in one batch, defaults to 1000 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'message_factory' =&gt; FQCNMessageFactory::class, \/\/ message factory to use, defauls to `FQCNMessageFactory::class` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'PostgresEventStore' =&gt; [ \\Prooph\\EventStore\\Container\\PostgresEventStoreFactory::class, 'default', ], ], ], \/\/... other application config here ] $eventStore = $container-&gt;get('PostgresEventStore');"},{"id":"\/interop_factories.html#3-1-7","title":"PostgresProjectionManagerFactory","content":"[ 'prooph' =&gt; [ 'projection_manager' =&gt; [ 'default' =&gt; [ 'event_store' =&gt; 'PostgresEventStore', 'connection' =&gt; 'my_pdo_connection', \/\/ service id for the used pdo connection 'event_streams_table' =&gt; 'event_streams', \/\/ event stream table to use, defaults to `event_streams` 'projections_table' =&gt; 'projections', \/\/ projection table to use, defaults to `projections` ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'PostgresProjectionManager' =&gt; [ \\Prooph\\EventStore\\Container\\PostgresProjectionManagerFactory::class, 'default', ], ], ], \/\/... other application config here ] $projectionManager = $container-&gt;get('PostgresProjectionManager');"},{"id":"\/interop_factories.html#3-1-8","title":"PdoConnectionFactory","content":"[ 'prooph' =&gt; [ 'pdo_connection' =&gt; [ 'default' =&gt; [ 'schema', \/\/ one of mysql or pgsql 'user', \/\/ username to use 'password', \/\/ password to use 'port', \/\/ port to use 'host' =&gt; '127.0.0.1', \/\/ host name, defaults to `127.0.0.1` 'dbname' =&gt; 'event_store', \/\/ database name, defaults to `event_store` 'charset' =&gt; 'utf8', \/\/ chartset, defaults to `UTF-8`, ], ], ], 'dependencies' =&gt; [ 'factories' =&gt; [ 'my_pdo_connection' =&gt; [ \\Prooph\\EventStore\\Container\\PdoConnectionFactory::class, 'default', ], ], ], \/\/... other application config here ] $pdoConnection = $container-&gt;get('my_pdo_connection');"}]